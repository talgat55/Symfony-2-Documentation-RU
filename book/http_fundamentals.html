
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Symfony2 и основы HTTP &mdash; Русская документация Symfony2</title>
    <link rel="stylesheet" href="../_static/css/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="top" title="Русская документация Symfony2" href="../index.html" />
    <link rel="up" title="Книга" href="index.html" />
    <link rel="next" title="Symfony2 против чистого PHP" href="from_flat_php_to_symfony2.html" />
    <link rel="prev" title="Книга" href="index.html" /> 

    <meta content="Русская документация Symfony2 на SymfonyGuru. Документация обновляется еженевно." name="Description">

    <meta content="русская документация symfony2, перевод документации Symfony2, symfony2, symfony 2, symfony, components, symphony, symfony framework" name="Keywords">

    <script type="text/javascript" src="../_static/js/doc.js"></script>

    <link rel="stylesheet" href="../_static/css/doc.css">

  </head>

  <body>

  <div id="wrapper">

      <div id="header_index">

          <div id="logo">
              <h1>
                  <a href="/ru/">
                      <img src="../_static/images/logo.png" width="168" height="40" alt="Logo"/>
                      <span id="logo-text">ГУРУ</span>
                  </a>
              </h1>
          </div>
          <!-- /#logo -->

          <div id="menu">

              <div id="right_bg"></div>

              <ul>

                  <li>
                      <a href="/ru/">Главная</a>
                  </li>

                  <li>
                      <a href="/blog/ru/">Блог</a>
                  </li>

                  <li>
                      <a href="/content/ru/about/">О проекте</a>
                  </li>

              </ul>
              <!-- /#menu ul -->

          </div>
          <!-- /#menu -->

          <div id="header_info" class="blog_info">

              <div class="left">
                  <a href="/ru/">Главная</a> /
                  <a href="/documentation/ru/html/index.html">Русская документация Symfony2</a>
              </div>

              <div class="right">
                  Сменить язык:
                  <a href="/documentation/en/html/index.html" class="en">EN</a>
              </div>

          </div>
          <!-- /#header_info -->

      </div>
      <!-- /#header -->

      <div id="top_box_index">

          <span class="top_box_top"></span>
          <!-- /.top_box_top - adds the top Background -->

          <div class="content">

              <div class="top_box_block" style="width: 100%;">

                  <h4>Русская документация Symfony2 на SymfonyGuru</h4>

                  <p style="width: 100%;">
                      <b>Дата последнего обновления: 2012-07-16.</b>
                      <!--
                      <br/>
                      Принять участие в переводе документации Symfony2 на русский язык
                      <a href="https://github.com/avalanche123/symfony-docs-ru/blob/master/README.rst" target="_blank">
                          может любой желающий
                      </a>.
                      -->
                  </p>

              </div>
              <!-- /.content .top_box_block -->

          </div>
          <!-- /#top_box .content -->

      </div>
      <!-- /#top_box -->

      <div id="content">
          
  <div class="section" id="symfony2-http">
<span id="index-0"></span><h1>Symfony2 и основы HTTP<a class="headerlink" href="#symfony2-http" title="Ссылка на этот заголовок">¶</a></h1>
<p>Поздравляем! Начав изучение Symfony2, вы встали на правильный путь, чтобы
стать более <em>продуктивным</em>, <em>всесторонне развитым</em> и <em>популярным</em> веб-разработчиком
(хотя последнее - на ваше усмотрение). Symfony2 создан, чтобы предоставлять базовые,
низкоуровневые инструменты, позволяющие вам разрабатывать быстрее, создавать более
надёжные приложения, но при этом быть в строне от вашего собственного пути.
Symfony построен на лучших идеях, заимствованных из различных технологий: инструменты
и концепции, которые вы готовитесь изучить - представлены усилиями тысяч и тысяч людей
на протяжении многих лет. Другими словами, вы не только изучаете &#8220;Symfony&#8221;, вы изучаете
основы web, лучшие практики разработки, а также способы использования многих замечательных
PHP-библиотек в составе Symfony2 или не зависимо от него. Итак, приготовьтесь.</p>
<p>Следуя философии Symfony2, эта глава начинается с объяснения основной концепции,
типичной для web-разработки: HTTP. Не зависимо от вашего опыта или любимого
языка программирования, эта глава <strong>обязательна к прочтению</strong> всем.</p>
<div class="section" id="http">
<h2>HTTP это Просто<a class="headerlink" href="#http" title="Ссылка на этот заголовок">¶</a></h2>
<p>HTTP (Hypertext Transfer Protocol или просто Протокол Передачи Гипертекста) - это
текстовый язык, позволяющий двум компьютерам обмениваться сообщениями друг с
другом. Вот и всё! Например, когда мы хотим посмотреть новенький комикс <a class="reference external" href="http://xkcd.com/">xkcd</a>,
имеет место (примерно) такой диалог:</p>
<img alt="../_images/http-xkcd.png" class="align-center" src="../_images/http-xkcd.png" />
<p>И пока используется реальный язык, хотя он и несколько более формальный, он
остаётся предельно простым. HTTP - это термин, используемый для описания этого
простого текстового языка. И не важно, как именно вы разрабатываете в web, целью
вашего сервера <em>всегда</em> является понять простой текстовый запрос и вернуть простой
текстовый ответ.</p>
<p>Symfony2 возвышается над этой реальностью. Что бы вы ни делали, HTTP - это то, что
вы используете ежедневно. С помощью Symfony2 вы узнаете, как управлять им.</p>
<div class="section" id="index-1">
<span id="id1"></span><h3>Шаг 1: Клиент отправляет запрос<a class="headerlink" href="#index-1" title="Ссылка на этот заголовок">¶</a></h3>
<p>Любой диалог в сети начинается с <em>запроса</em>. Запрос - это текстовое сообщение,
создаваемое клиентом (например браузером или iPhone приложением и т.д.) в особом
формате, также известном как HTTP. Клиент отправляет этот запрос серверу, и
ожидает ответ.</p>
<p>Взгляните на первую часть взаимодействия (запрос) между браузером и веб-сервером
xkcd:</p>
<img alt="../_images/http-xkcd-request.png" class="align-center" src="../_images/http-xkcd-request.png" />
<p>На языке HTTP этот запрос будет выглядеть примерно так:</p>
<div class="highlight-text"><div class="highlight"><pre>GET / HTTP/1.1
Host: xkcd.com
Accept: text/html
User-Agent: Mozilla/5.0 (Macintosh)
</pre></div>
</div>
<p>Это простое сообщение содержит <em>всю</em> необходимую информацию о том, какой
именно ресурс запрашивает клиент. Первая строка HTTP запроса наиболее
важна - она содержит 2 вещи: запрошенный URI и HTTP-метод.</p>
<p>URI (например <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contact</span></tt>, и т.д.) - это уникальный адрес или место,
которое определяет запрошенный клиентом ресурс. HTTP-метод (например <tt class="docutils literal"><span class="pre">GET</span></tt>)
определяет, что именно вы хотите сделать с запрошенным ресурсом. HTTP методы
это <em>глаголы</em> в запросе и они определяют несколько типичных путей, которыми
вы можете взаимодействовать с запрошенным ресурсом:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr><td><em>GET</em></td>
<td>Получить ресурс с сервера</td>
</tr>
<tr><td><em>POST</em></td>
<td>Создать ресурс на сервере</td>
</tr>
<tr><td><em>PUT</em></td>
<td>Обновить ресурс на сервере</td>
</tr>
<tr><td><em>DELETE</em></td>
<td>Удалить ресурс с сервера</td>
</tr>
</tbody>
</table>
<p>Запомнив эти типы HTTP-методов, вы можете представить себе, как будет
выглядеть HTTP-запрос на удаление записи в блоге:</p>
<div class="highlight-text"><div class="highlight"><pre>DELETE /blog/15 HTTP/1.1
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">На самом деле всего существует девять HTTP-методов, определённых в
спецификации протокола HTTP, но многие из них очень мало распространены
или же ограниченно поддерживаются. К примеру, многие современные браузеры
не поддерживают методы <tt class="docutils literal"><span class="pre">PUT</span></tt> и <tt class="docutils literal"><span class="pre">DELETE</span></tt>.</p>
</div>
<p>В дополнение к первой строке, HTTP-запрос всегда содержит несколько
информационных строк, именуемых заголовками (headers). Заголовки могут
предоставлять различную информацию, такую как запрошенный <tt class="docutils literal"><span class="pre">Host</span></tt>,
форматы ответа, которые поддерживает клиент (<tt class="docutils literal"><span class="pre">Accept</span></tt>) и приложение,
используемое клиентом для выполнения запроса (<tt class="docutils literal"><span class="pre">User-Agent</span></tt>). Существует
также много других заголовков, перечень которых вы можете найти в Википедии
на странице <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">List of HTTP header fields</a>.</p>
</div>
<div class="section" id="id2">
<h3>Шаг 2: Сервер возвращает ответ<a class="headerlink" href="#id2" title="Ссылка на этот заголовок">¶</a></h3>
<p>С того момента как сервер получил запрос, он точно знает, какой ресурс нужен
клиенту (основываясь на URI) и что клиент хочет с этим ресурсом сделать - на
основании HTTP-метода. Например, в случае GET-запроса, сервер подготовит
запрошенный ресурс и возвратит его в виде HTTP-ответа. Рассмотрим ответ
от web сервера xkcd:</p>
<img alt="../_images/http-xkcd.png" class="align-center" src="../_images/http-xkcd.png" />
<p>Переведённый в формат HTTP, ответ, отправленный обратно в браузер, будет выглядеть
примерно так:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 02 Apr 2011 21:05:05 GMT
Server: lighttpd/1.4.19
Content-Type: text/html

&lt;html&gt;
  &lt;!-- HTML for the xkcd comic --&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>HTTP-ответ содержит запрошенный ресурс (в данном случае это HTML-код страницы),
а также дополнительные данные о самом ответе. Первая строка особенно важна - она
содержит HTTP статус-код (в данном случае 200). Статус-код сообщает о результате
выполнения запроса, направляемом клиенту. Был ли запрос успешен? Была ли в ходе
выполнения запроса ошибка? Одни статус-коды обозначают успешные запросы, другие
- ошибки, третьи сообщают, что клиент должен выполнить что-либо (например
перенаправление на другую страницу). Полный список вы можете найти странице
<a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">List of HTTP status codes</a> в Википедии.</p>
<p>Подобно запросу, HTTP-ответ содержит дополнительную информацию, называемую
HTTP-заголовками. Например, важным заголовком HTTP-ответа является  <tt class="docutils literal"><span class="pre">Content-Type</span></tt>.
Тело одного и того же ресурса может быть возвращено во множестве различных форматов,
включая HTML, XML или JSON. Заголовок <tt class="docutils literal"><span class="pre">Content-Type</span></tt> сообщает клиенту, какой именно
формат используется в данном ответе.</p>
<p>Существует много различных заголовков, некоторые из них предоставляют большие
возможности. Например, некоторые заголовки могут быть использованы для
создания системы кэширования.</p>
</div>
<div class="section" id="web">
<h3>Запросы, Ответы и Web-разработка<a class="headerlink" href="#web" title="Ссылка на этот заголовок">¶</a></h3>
<p>Обмен запросами-ответами - это фундаментальный процесс, который движет все
коммуникации во всемирной сети. И насколько важен этот процесс, настолько он
прост.</p>
<p>Наиболее важным является следующий факт: вне зависимости от того, какой
языка программирования вы используете, какое приложение создаёте (web,
мобильное, JSON API) и даже какой философии следуете в разработке ПО,
конечной целью приложения <strong>всегда</strong> будет приём и разбор запроса и создание
соответствующего ответа.</p>
<p>Symfony спроектирован исходя из этих реалий.</p>
<div class="admonition tip">
<p class="first admonition-title">Совет</p>
<p class="last">Для того чтобы узнать больше про спецификацию HTTP, прочитайте оригинал
<a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP 1.1 RFC</a> или же <a class="reference external" href="http://datatracker.ietf.org/wg/httpbis/">HTTP Bis</a>, который является инициативой по
разъяснению оригинальной спецификации. Замечательный инструмент для
проверки заголовков запроса и ответа при сёрфинге - это расширение для
Firefox <a class="reference external" href="https://addons.mozilla.org/en-US/firefox/addon/3829/">Live HTTP Headers</a>.</p>
</div>
</div>
</div>
<div class="section" id="php">
<span id="index-2"></span><h2>Запросы и ответы в PHP<a class="headerlink" href="#php" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как же вы обрабатываете &#8220;запрос&#8221; и создаете &#8220;ответ&#8221; при использовании PHP?
На самом деле PHP немного абстрагирует вас от процесса:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="nv">$uri</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;REQUEST_URI&#39;</span><span class="p">];</span>
<span class="nv">$foo</span> <span class="o">=</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">];</span>

<span class="nb">header</span><span class="p">(</span><span class="s1">&#39;Content-type: text/html&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s1">&#39;The URI requested is: &#39;</span><span class="o">.</span><span class="nv">$uri</span><span class="p">;</span>
<span class="k">echo</span> <span class="s1">&#39;The value of the &quot;foo&quot; parameter is: &#39;</span><span class="o">.</span><span class="nv">$foo</span><span class="p">;</span>
</pre></div>
</div>
<p>Как бы странно это ни звучало, но это крохотное приложение получает
информацию из HTTP-запроса и использует её для создания HTTP-ответа.
Вместо того, чтобы парсить необработанный HTTP-запрос, PHP подготавливает
суперглобальные переменные, такие как <tt class="docutils literal"><span class="pre">$_SERVER</span></tt> и <tt class="docutils literal"><span class="pre">$_GET</span></tt>, которые содержат
всю информацию о запросе. Аналогично, вместо того, чтобы возвращать текст
ответа, форматированный по правилам HTTP, вы можете использовать функции
<tt class="docutils literal"><span class="pre">header()</span></tt> для создания заголовков ответов и просто вывести на печать
основной контент, который станет контентным блоком ответа. В заключении
PHP создаст правильный HTTP-ответ и вернет его клиенту:</p>
<div class="highlight-text"><div class="highlight"><pre>HTTP/1.1 200 OK
Date: Sat, 03 Apr 2011 02:14:33 GMT
Server: Apache/2.2.17 (Unix)
Content-Type: text/html

The URI requested is: /testing?foo=symfony
The value of the &quot;foo&quot; parameter is: symfony
</pre></div>
</div>
</div>
<div class="section" id="symfony">
<h2>Запросы и ответы в Symfony<a class="headerlink" href="#symfony" title="Ссылка на этот заголовок">¶</a></h2>
<p>Symfony предоставляет альтернативу прямолинейному подходу из PHP посредством
двух классов, которые позволяют взаимодействовать с HTTP-запросом и ответом
самым простейшим способом. Класс <tt class="xref py py-class docutils literal"><span class="pre">Symfony\Component\HttpFoundation\Request</span></tt> - это
простое объектно-ориентированное представление сообщения HTTP-запроса. С его помощью
вы имеете все данные из запроса &#8220;на кончиках пальцев&#8221;:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">();</span>

<span class="c1">// запрошенный URI (на пример /about) без query parameters</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">();</span>

<span class="c1">// получаем GET и POST переменные соответственно</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">request</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span>

<span class="c1">// получаем экземпляр UploadedFile определяемый идентификатором foo</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">files</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>

<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getMethod</span><span class="p">();</span>          <span class="c1">// GET, POST, PUT, DELETE, HEAD</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getLanguages</span><span class="p">();</span>       <span class="c1">// массив языков, принимаемых клиентом</span>
</pre></div>
</div>
<p>В качестве бонуса, класс <tt class="docutils literal"><span class="pre">Request</span></tt> выполняет большой объём работы в фоновом
режиме, так что вам не придется заботиться о многих вещах. Например, метод
<tt class="docutils literal"><span class="pre">isSecure()</span></tt> проверяет <em>три</em> различных значения в PHP, которые указывают,
что пользователь подключается по защищенному протоколу (<tt class="docutils literal"><span class="pre">https</span></tt>).</p>
<p>Symfony также предоставляет класс <tt class="docutils literal"><span class="pre">Response</span></tt>: простое РHP-представление
HTTP-ответа. Это позволяет вашему приложению использовать объектно-ориентированный
интерфейс для конструирования ответа, который нужно вернуть клиенту:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Response</span><span class="p">;</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>

<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setContent</span><span class="p">(</span><span class="s1">&#39;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#39;</span><span class="p">);</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/html&#39;</span><span class="p">);</span>

<span class="c1">// prints the HTTP headers followed by the content</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>Если бы Symfony ничего вам не предлагала, вы всегда должны были бы иметь набор
инструментов для того чтобы можно было просто и быстро получить доступ к информации
из запроса и объектно-ориентированный интерфейс для создания ответа. Даже
если вы освоите более мощные возможности в Symfony, всегда держите в голове,
что цель вашего приложения всегда заключается в том, чтобы <em>интерпретировать
запрос и создать соответствующий ответ, основываясь на логике вашего
приложения</em></p>
<div class="admonition tip">
<p class="first admonition-title">Совет</p>
<p class="last">Классы <tt class="docutils literal"><span class="pre">Request</span></tt> и <tt class="docutils literal"><span class="pre">Response</span></tt> являются частью самостоятельного
компонента <tt class="docutils literal"><span class="pre">HttpFoundation</span></tt>. Этот компонент может быть использован
независимо от Symfony и он также предоставляет классы для работы с
сессиями и загрузки файлов.</p>
</div>
</div>
<div class="section" id="id3">
<h2>Путешествие от Запроса до Ответа<a class="headerlink" href="#id3" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как и HTTP-протокол, объекты <tt class="docutils literal"><span class="pre">Request</span></tt> и <tt class="docutils literal"><span class="pre">Response</span></tt> достаточно просты.
Самая сложная часть создания приложения заключается в написании процессов,
которые происходят между получением запроса и отправкой ответа. Другими
словами, реальная работа заключается в написании кода, который интерпретирует
информацию запроса и создает ответ (логика приложения).</p>
<p>Ваше приложение может иметь много функций, например, отправлять email&#8217;ы,
обрабатывать отправленные формы, сохранять что-то в базу данных, отображать
HTML-страницы и защищать контент правилами безопасности. Как управляться со
всем этим и чтобы при этом код оставался хорошо организованным и поддерживаемым?</p>
<p>Symfony создана специально для решения этих проблем, значит, вам не придется
их решать.</p>
<div class="section" id="id4">
<h3>Фронт-контроллер<a class="headerlink" href="#id4" title="Ссылка на этот заголовок">¶</a></h3>
<p>Традиционно приложения создавались таким образом, чтобы каждая &#8220;страница&#8221;
имела свой собственный файл:</p>
<div class="highlight-text"><div class="highlight"><pre>index.php
contact.php
blog.php
</pre></div>
</div>
<p>При таком подходе имеется целый ряд проблем, включая жёсткие URLы (что если
вам потребуется изменить <tt class="docutils literal"><span class="pre">blog.php</span></tt> на <tt class="docutils literal"><span class="pre">news.php</span></tt> и при этом сохранить
все ваши ссылки?), а также необходимость вручную включать в каждый файл
кучу файлов, включающих безопасность, работу с базами данных.</p>
<p>Много более удачным является подход с использованием <em class="xref std std-term">front controller</em>,
единственного PHP-файла, который отвечает за каждый запрос к вашему приложению.
Например:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">/index.php</span></tt></td>
<td>выполняет <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">/index.php/contact</span></tt></td>
<td>выполняет <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">/index.php/blog</span></tt></td>
<td>выполняет <tt class="docutils literal"><span class="pre">index.php</span></tt></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="first admonition-title">Совет</p>
<p class="last">С использованием модуля <tt class="docutils literal"><span class="pre">mod_rewrite</span></tt> для Apache (или эквивалента
для других web-серверов) URLы легко очистить от упоминания фронт-контроллера,
т.е. останется лишь <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">/contact</span></tt> и <tt class="docutils literal"><span class="pre">/blog</span></tt>.</p>
</div>
<p>Теперь, каждый запрос обрабатывается однообразно. Вместо того чтобы
каждый URL соответствовал отдельному PHP-файлу - фронт-контроллер выполняется
<em>всегда</em> и посредством маршрутизатора вызывает различные части вашего
приложения, в зависимости от URL. Это решает многие проблемы, которые
порождал традиционный подход. Практически все современные приложения
используют этот подход, например WordPress.</p>
</div>
<div class="section" id="id5">
<h3>Будьте организованы<a class="headerlink" href="#id5" title="Ссылка на этот заголовок">¶</a></h3>
<p>Итак, мы внутри вашего фронт-контроллера. Но как мы узнаем, какая страница
должна быть отображена и как её сформировать? В любом случае вам нужно
проверить входящий URI и выполнить какую-то из частей вашего кода, в зависимости
от этого значения. Это можно сделать быстро и весьма коряво:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>
<span class="c1">// index.php</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">();</span>
<span class="nv">$path</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">();</span> <span class="c1">// запрошенный URL</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">in_array</span><span class="p">(</span><span class="nv">$path</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">))</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Welcome to the homepage.&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">elseif</span> <span class="p">(</span><span class="nv">$path</span> <span class="o">==</span> <span class="s1">&#39;/contact&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Contact us&#39;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;Page not found.&#39;</span><span class="p">,</span> <span class="mi">404</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>Решить же эту проблему достаточно сложно. К счастью, Symfony создана <em>именно</em>
для этого.</p>
</div>
<div class="section" id="id6">
<h3>Как устроено Symfony приложение<a class="headerlink" href="#id6" title="Ссылка на этот заголовок">¶</a></h3>
<p>Когда вы даёте возможность Symfony обрабатывать запросы, жизнь становится много
проще. Symfony следует простому шаблону при обработке каждого запроса:</p>
<div class="figure align-center" id="request-flow-figure">
<img alt="Symfony2 request flow" src="../_images/request-flow.png" />
<p class="caption">Входящие запросы интерпретируются маршрутизатором и передаются в
функцию-контроллер, которая возвращает объект <tt class="docutils literal"><span class="pre">Response</span></tt>.</p>
</div>
<p>Каждая &#8220;страница&#8221; вашего сайта должна быть определена в конфигурации
маршрутизатора, чтобы распределять различные URL по различным PHP-функциям.
Обязанность каждой такой функции, называемой <em class="xref std std-term">controller</em>, используя
информацию из запроса - а также используя прочий инструментарий, доступный в
Symfony, создать и вернуть объект <tt class="docutils literal"><span class="pre">Response</span></tt>. Другими словами, контроллер
содержит <em>ваш</em> код: именно там вы должны превратить запрос в ответ.</p>
<p>Это не сложно! Давайте-ка взглянем:</p>
<ul class="simple">
<li>Каждый запрос обрабатывается фронт-контроллером;</li>
<li>Система маршрутизации определяет, какую именно PHP-функцию необходимо
выполнить, основываясь на информации из запроса и конфигурации маршрутизатора,
которую вы создали;</li>
<li>Вызывается необходимая функция, в которой написанный вами код создаёт и возвращает
соответствующий логике приложения объект <tt class="docutils literal"><span class="pre">Response</span></tt>.</li>
</ul>
</div>
<div class="section" id="symfony-request">
<h3>Symfony Request в действии<a class="headerlink" href="#symfony-request" title="Ссылка на этот заголовок">¶</a></h3>
<p>Не закапываясь глубоко в детали, давайте посмотрим на этот процесс в
действии. Предположим, вы хотите добавить страницу <tt class="docutils literal"><span class="pre">/contact</span></tt> к вашему
Symfony приложению. Во-первых, надо добавить конфигурацию маршрутизатора для
<tt class="docutils literal"><span class="pre">/contact</span></tt> URI:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span class="l-Scalar-Plain">contact</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">pattern</span><span class="p-Indicator">:</span>  <span class="l-Scalar-Plain">/contact</span>
    <span class="l-Scalar-Plain">defaults</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">_controller</span><span class="p-Indicator">:</span> <span class="nv">AcmeDemoBundle</span><span class="p-Indicator">:</span><span class="nv">Main</span><span class="p-Indicator">:</span><span class="nv">contact</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Этот пример использует <tt class="xref doc docutils literal"><span class="pre">YAML</span></tt> для того чтобы определить
конфигурацию маршрутизатора. Конфигурацию можно также задавать и в других
форматах - таких как XML или PHP.</p>
</div>
<p>Когда кто-либо посещает страницу <tt class="docutils literal"><span class="pre">/contact</span></tt>, URI совпадает с маршрутом и
указанный нами ранее контроллер выполняется. Как вы узнаете в из главы <a class="reference internal" href="routing.html"><em>Маршрутизация</em></a>,
строка <tt class="docutils literal"><span class="pre">AcmeDemoBundle:Main:contact</span></tt> это короткая форма записи, которая указывает на
особый метод <tt class="docutils literal"><span class="pre">contactAction</span></tt>, определённый в классе <tt class="docutils literal"><span class="pre">MainController</span></tt>:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="cp">&lt;?php</span>

<span class="k">class</span> <span class="nc">MainController</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">contactAction</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span><span class="s1">&#39;&lt;h1&gt;Contact us!&lt;/h1&gt;&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>В этом очень простом примере, контроллер создает объект <tt class="docutils literal"><span class="pre">Response</span></tt>,
содержащий лишь простенький HTML-код &#8220;&lt;h1&gt;Contact us!&lt;/h1&gt;&#8221;. В главе
<a class="reference internal" href="controller.html"><em>Контроллер</em></a>, вы узнаете, как контроллер может
отображать шаблоны, позволяя &#8220;представлению&#8221; существовать раздельно от кода
в файлах шаблонов. Это дает возможность сосредоточиться в контроллере на
работе с базами данных, обработке отправленных пользователем данных или
отправке email сообщений.</p>
</div>
</div>
<div class="section" id="symfony2">
<h2>Symfony2: Создавайте приложение, а не инструменты.<a class="headerlink" href="#symfony2" title="Ссылка на этот заголовок">¶</a></h2>
<p>Теперь вы знаете, что цель вашего приложения заключается в интерпретации
входящих запросов и создании адекватного ситуации ответа. По мере роста
приложения становится все труднее содержать свой код в порядке. Без сомнений,
эта же задача будет повторяться снова и снова: сохранение данных в базу,
отображение и повторное использование шаблонов, обработка форм, отправка emails,
валидация данных, введённых пользователем и безопасность.</p>
<p>Хорошие новости заключаются в том, что эти проблемы не уникальны. Symfony
предоставляет Фреймворк, полный инструментов, которые позволят вам создать
ваше собственное приложение, а не ваши инструменты. При помощи Symfony2 вы
использовать Фреймворк целиком или же только его часть.</p>
<div class="section" id="index-3">
<span id="id7"></span><h3>Автономные библиотеки: <em>Компоненты</em> Symfony2<a class="headerlink" href="#index-3" title="Ссылка на этот заголовок">¶</a></h3>
<p>Что же собой представляет Symfony2? Прежде всего, Symfony2 - это коллекция
более чем 20 независимых библиотек, которые могут быть использованы <em>в любом</em>
PHP-проекте. Эти библиотеки, называемые <em>Symfony2 Components</em>, содержат полезные
методы практически на любой случай жизни, не зависимо от того как именно ваш проект
разрабатывается. Вот некоторые из них:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/symfony/HttpFoundation">HttpFoundation</a> - Содержит классы <tt class="docutils literal"><span class="pre">Request</span></tt> и <tt class="docutils literal"><span class="pre">Response</span></tt>, а также
классы для работы с сессиями и загрузкой файлов;</li>
<li><a class="reference external" href="https://github.com/symfony/Routing">Routing</a> - мощная система маршрутизации, которая позволяет вам ставить
в соответствие некоторому URI (например <tt class="docutils literal"><span class="pre">/contact</span></tt>) информацию о том, как
этот запрос должен быть обработан (например вызвать метод <tt class="docutils literal"><span class="pre">contactAction()</span></tt>);</li>
<li><a class="reference external" href="https://github.com/symfony/Form">Form</a> - многофункциональный и гибкий фреймворк для создания форм обработки
их сабмита;</li>
<li><a class="reference external" href="https://github.com/symfony/Validator">Validator</a> - система, предназначенная для создания правил для данных
и последующей валидации - соответствуют ли данные, отправленные пользователями
этим правилам;</li>
<li><a class="reference external" href="https://github.com/symfony/ClassLoader">ClassLoader</a> - библиотека, позволяющая использовать PHP-классы без
использования явного <tt class="docutils literal"><span class="pre">require</span></tt> для файлов, включающих требуемые классы.</li>
<li><a class="reference external" href="https://github.com/symfony/Templating">Templating</a> - тулкит для рендеринга шаблонов, поддерживает наследование
шаблонов (например, декорирование шаблонов при помощи родительского шаблона aka layout),
а также прочие типичные для шаблонов операции (escaping, условия, циклы и т.д.);</li>
<li><a class="reference external" href="https://github.com/symfony/Security">Security</a> мощная библиотека для обеспечения всех типов безопасности
внутри приложения;</li>
<li><a class="reference external" href="https://github.com/symfony/Translation">Translation</a> - Фреймворк для поддержки переводов в вашем приложении.</li>
</ul>
<p>Каждый из этих компонентов независим и может быть использован в <em>любом</em>
PHP-проекте, не зависимо от Symfony2.</p>
</div>
<div class="section" id="symfony2-framework">
<h3>Комплексное решение: Symfony2 <em>Framework</em><a class="headerlink" href="#symfony2-framework" title="Ссылка на этот заголовок">¶</a></h3>
<p>Ну так что же это <em>такое</em> - Symfony2 <em>Framework</em>? <em>Symfony2 Framework</em>
это PHP библиотека, которая решает 2 различных задачи:</p>
<ol class="arabic simple">
<li>Предоставляет набор отобранных компонент (Symfony2 Components) и
сторонних библиотек (например <tt class="docutils literal"><span class="pre">Swiftmailer</span></tt> для отправки почты);</li>
<li>Предоставляет возможности по конфигурированию всего этого добра и &#8220;клей&#8221;,
который скрепляет все библиотеки в единое целое.</li>
</ol>
<p>Цель фреймворка - интеграция независимых инструментов и обеспечение их
совместной работы. Сам фреймворк представляет собой Symfony Bundle
(плагин), который можно конфигурировать или даже заменить.</p>
<p>Symfony2 предоставляет замечательный набор инструментов для быстрой разработки
web-приложений, ничего не навязывающий непосредственно вашему приложению.
Разработчик может быстро приступить к разработке, используя дистрибутив Symfony2,
который предоставляет скелетон с типовыми настройками. А для пытливых умов...
у неба нет потолка! )</p>
</div>
</div>
</div>


      </div>
      <!-- /#content -->

  </div>
  <!-- /#wrapper -->

  <div id="copyright">
      <div id="copyright_wrapper">
          <ul class="left">
              <li><a href="/ru/">Главная</a></li>
              <li><a href="/content/ru/about/">О проекте</a></li>
          </ul>
          <!-- /.left content-->
          <span class="right">
              Этот сайт создал и поддерживает <a href="http://hudson.su" target="_blank">Дмитрий Быкадоров</a> 2011
              <br/>
              <b>Symfony</b> is a <a href="http://symfony.com/trademark" target="_blank">trademark of Fabien Potencier</a>. All rights reserved.
          </span>
          <!-- /.right content-->
      </div>
      <!-- /#copyright _wrapper-->
  </div>

  <!-- Yandex.Metrika counter -->
  <div style="display:none;"><script type="text/javascript">
  (function(w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter9710512 = new Ya.Metrika({id:9710512, enableAll: true, trackHash:true});
          }
          catch(e) { }
      });
  })(window, "yandex_metrika_callbacks");
  </script></div>
  <script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script>
  <noscript><div><img src="//mc.yandex.ru/watch/9710512" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <!-- /Yandex.Metrika counter -->

  <!-- Google analytics -->
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-11137454-5']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  <!-- /Google analytics -->

  </body>
</html>